<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>City Temperature Heatmap</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="vendor/maplibre-gl.css" rel="stylesheet" />
  <style>
    html, body { margin: 0; height: 100%; }
    #map { position: absolute; inset: 0; }
    #ui {
      position: absolute; top: 10px; left: 10px; z-index: 10;
      background: #fff; padding: 12px; border-radius: 10px;
      font: 14px/1.25 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      box-shadow: 0 4px 20px rgba(0,0,0,.12); width: 320px;
    }
    #ui label { display: block; margin: 8px 0 4px; font-weight: 600; }
    #ui .row { display: flex; gap: 8px; align-items: center; }
    #ui .row input[type=range] { flex: 1; }
    .small { font-size: 12px; opacity:.75; }
    .divider{ height:1px; background:#e5e7eb; margin:10px 0; }
    input[type=number]{ width:90px; padding:4px 6px; }
    select{ padding:4px 6px; }
    #badge {
      position: absolute; bottom: 10px; left: 10px; z-index: 10;
      background: #fff; padding: 6px 8px; border-radius: 8px;
      font: 12px system-ui, sans-serif; box-shadow: 0 2px 12px rgba(0,0,0,.12);
    }
    #chartContainer {
      position:absolute; top:10px; right:10px; width:360px; height:240px;
      background:#fff; opacity:0.95; padding:10px; border-radius:8px;
      display:none; z-index:20;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div id="ui">
    <div class="row" style="justify-content:space-between;">
      <strong>Temperature Heatmap</strong>
      <span id="status" class="small">loading…</span>
    </div>

    <label for="hour">Hour</label>
    <div class="row">
      <input id="hour" type="range" min="0" max="23" step="1" value="19" />
      <span id="hourLabel" style="width:80px; text-align:right;">19:00</span>
    </div>

    <label for="place">Place</label>
    <select id="place">
      <option value="__all__">All places</option>
      <option value="sparafucile">sparafucile</option>
      <option value="parcote">parcote</option>
    </select>

    <div class="divider"></div>
    <strong>Heatmap scale</strong>

    <label for="scaleMode">Scale mode</label>
    <select id="scaleMode">
      <option value="auto" selected>Auto (per hour + place)</option>
      <option value="fixed">Fixed</option>
    </select>

    <label class="small">Fixed min/max (°C)</label>
    <div class="row">
      <input id="fixedMin" type="number" step="0.1" value="24">
      <input id="fixedMax" type="number" step="0.1" value="36">
    </div>

    <div class="small" style="margin-top:6px;">
      Colors are Green→Yellow→Red. Zoom is stabilized internally.
    </div>
  </div>

  <div id="badge">Data: PMTiles (Cloudflare R2) · MapLibre GL</div>
  <div id="chartContainer"><canvas id="tempChart"></canvas></div>

  <script src="vendor/maplibre-gl.js"></script>
  <script src="vendor/pmtiles.js"></script>
  <script src="vendor/basemaps.js"></script>
  <script src="vendor/pbf.min.js"></script>
  <script src="vendor/vector-tile.js"></script>
  <script src="vendor/chart.umd.js"></script>
  <script src="vendor/chartjs-plugin-annotation.min.js"></script>
  <script>
    if (window['chartjs-plugin-annotation']) Chart.register(window['chartjs-plugin-annotation']);
    else if (window.ChartAnnotation) Chart.register(window.ChartAnnotation);
  </script>

  <script>
    // --- Config ---
    const PMTILES_BASEMAP = "pmtiles://https://pub-7d28cd0e85994386bd14b8b8fa86a6d7.r2.dev/mantua_basemap.pmtiles";
    const PMTILES_TEMPS   = "pmtiles://https://pub-7d28cd0e85994386bd14b8b8fa86a6d7.r2.dev/all_temps.pmtiles";
    const LAYER_NAME = "temps";
    const DATE = "2025-07-23";
    const INIT_CENTER = [10.80, 45.16];
    const INIT_ZOOM = 12.2;
    const DECODE_ZOOM = 14;
    const CLICK_MAX_M = 60;
    const DATA_BOUNDS = [10.785482, 45.145304, 10.814915, 45.167814];

    const hours24 = Array.from({length:24}, (_,i)=> `${DATE}T${String(i).padStart(2,"0")}:00`);
    const currentTimeStr = () => `${DATE}T${String($hour.value).padStart(2,"0")}:00`;

    // --- DOM refs ---
    const $status = document.getElementById("status");
    const $hour = document.getElementById("hour");
    const $hourLabel = document.getElementById("hourLabel");
    const $place = document.getElementById("place");
    const $scaleMode = document.getElementById("scaleMode");
    const $fixedMin = document.getElementById("fixedMin");
    const $fixedMax = document.getElementById("fixedMax");
    const chartContainer = document.getElementById("chartContainer");
    let chart = null;

    // --- PMTiles protocol ---
    const protocol = new pmtiles.Protocol();
    maplibregl.addProtocol("pmtiles", protocol.tile);
    const archiveTemps = new pmtiles.PMTiles(PMTILES_TEMPS.replace("pmtiles://",""));
    const archiveBase  = new pmtiles.PMTiles(PMTILES_BASEMAP.replace("pmtiles://",""));
    protocol.add(archiveTemps);
    protocol.add(archiveBase);

    // --- Helpers ---
    function lonlatToTile(lon, lat, z) {
      const x = Math.floor(((lon + 180) / 360) * Math.pow(2, z));
      const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI/180) + 1/Math.cos(lat * Math.PI/180)) / Math.PI) / 2 * Math.pow(2, z));
      return { x, y };
    }
    const wrap = (n, mod) => ((n % mod) + mod) % mod;
    function haversine(lon1, lat1, lon2, lat2) {
      const R = 6371000, toRad = d => d*Math.PI/180;
      const dLat = toRad(lat2-lat1), dLon = toRad(lon2-lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(a));
    }
    async function decodeTileToPoints(z, x, y) {
      try {
        const resp = await archiveTemps.getZxy(z, x, y);
        if (!resp || !resp.data) return [];
        const vt = new window.vectorTile.VectorTile(new window.Pbf(new Uint8Array(resp.data)));
        const layer = vt.layers[LAYER_NAME];
        if (!layer) return [];
        const feats = [];
        for (let i=0; i<layer.length; i++) {
          const f = layer.feature(i).toGeoJSON(x, y, z);
          if (f.geometry?.type === "Point") feats.push(f);
        }
        return feats;
      } catch { return []; }
    }
    async function decodeBoundsToPoints(bounds = DATA_BOUNDS, z = DECODE_ZOOM) {
      const [minLon, minLat, maxLon, maxLat] = bounds;
      const tl = lonlatToTile(minLon, maxLat, z);
      const br = lonlatToTile(maxLon, minLat, z);
      const n = Math.pow(2, z);
      const xMin = Math.max(0, Math.min(tl.x, br.x));
      const xMax = Math.min(n - 1, Math.max(tl.x, br.x));
      const yMin = Math.max(0, Math.min(tl.y, br.y));
      const yMax = Math.min(n - 1, Math.max(tl.y, br.y));
      const promises = [];
      for (let x = xMin; x <= xMax; x++) {
        for (let y = yMin; y <= yMax; y++) promises.push(decodeTileToPoints(z, x, y));
      }
      const chunks = await Promise.all(promises);
      return chunks.flat();
    }
    async function pickNearbyFeature(lon, lat, placeFilter) {
      const { x, y } = lonlatToTile(lon, lat, DECODE_ZOOM);
      const n = Math.pow(2, DECODE_ZOOM);
      const coords = [];
      for (let dx=-1; dx<=1; dx++) for (let dy=-1; dy<=1; dy++) coords.push([wrap(x+dx,n), wrap(y+dy,n)]);
      const chunks = await Promise.all(coords.map(([tx,ty]) => decodeTileToPoints(DECODE_ZOOM, tx, ty)));
      const all = chunks.flat();
      const filtered = placeFilter ? all.filter(g => g.properties?.place === placeFilter) : all;
      let best = null, bestD = Infinity;
      for (const g of filtered) {
        const [gx, gy] = g.geometry.coordinates;
        const d = haversine(lon, lat, gx, gy);
        if (d < bestD) { best = g; bestD = d; }
      }
      return (best && bestD <= CLICK_MAX_M) ? best : null;
    }
    async function loadSeriesByPixelId(pixelId, lonHint, latHint, placeFilter) {
      const { x, y } = lonlatToTile(lonHint, latHint, DECODE_ZOOM);
      const n = Math.pow(2, DECODE_ZOOM);
      const coords = [];
      for (let dx=-1; dx<=1; dx++) for (let dy=-1; dy<=1; dy++) coords.push([wrap(x+dx,n), wrap(y+dy,n)]);
      const chunks = await Promise.all(coords.map(([tx,ty]) => decodeTileToPoints(DECODE_ZOOM, tx, ty)));
      const all = chunks.flat();
      const rows = all.filter(f =>
        String(f.properties?.pixel_id) === String(pixelId) &&
        (!placeFilter || f.properties?.place === placeFilter)
      );
      const m = new Map();
      for (const f of rows) {
        const p = f.properties || {};
        if (p.time && typeof p.value !== "undefined") m.set(p.time, Number(p.value));
      }
      return m;
    }

    // --- Style ---
    const basemapSourceId = "basemap";
    const style = {
      version: 8,
      glyphs: "https://protomaps.github.io/basemaps-assets/fonts/{fontstack}/{range}.pbf",
      sprite: "https://protomaps.github.io/basemaps-assets/sprites/v4/light",
      sources: {
        [basemapSourceId]: {
          type: "vector",
          url: PMTILES_BASEMAP,
          minzoom: 0, maxzoom: 14,
          attribution: '<a href="https://protomaps.com">Protomaps</a> © <a href="https://openstreetmap.org">OpenStreetMap</a>'
        },
        temps: { type: "vector", url: PMTILES_TEMPS, minzoom: 8 }
      },
      layers: (window.basemaps
        ? window.basemaps.layers(basemapSourceId, window.basemaps.namedFlavor("light"), { lang: "en" })
        : [{ id:"bg", type:"background", paint:{ "background-color":"#f3f4f6" }}])
    };

    // --- Map init ---
    const map = new maplibregl.Map({ container: "map", style, center: INIT_CENTER, zoom: INIT_ZOOM, maxZoom: 22 });
    map.addControl(new maplibregl.NavigationControl(), "top-right");
    map.addControl(new maplibregl.ScaleControl({ unit: "metric" }));
    map.on("error", (e) => console.error("Map error:", e?.error || e));

    function buildFilter() {
      const timeFilter = ["==", ["get","time"], currentTimeStr()];
      const p = $place.value;
      return (p === "__all__") ? timeFilter : ["all", timeFilter, ["==", ["get","place"], p]];
    }

    // --- Per-hour/per-place min/max cache (for Auto mode) ---
    const globalMinMaxCache = new Map();
    async function getGlobalMinMaxFor(hourStr, placeValue) {
      const key = `${hourStr}|${placeValue}`;
      if (globalMinMaxCache.has(key)) return globalMinMaxCache.get(key);
      const all = await decodeBoundsToPoints(DATA_BOUNDS, DECODE_ZOOM);
      const filtered = all.filter(f =>
        f.properties?.time === hourStr &&
        (placeValue === "__all__" || f.properties?.place === placeValue)
      );
      if (!filtered.length) {
        const fallback = { min: 24, max: 36 };
        globalMinMaxCache.set(key, fallback);
        return fallback;
      }
      let minVal = Infinity, maxVal = -Infinity;
      for (const f of filtered) {
        const v = Number(f.properties?.value);
        if (Number.isFinite(v)) {
          if (v < minVal) minVal = v;
          if (v > maxVal) maxVal = v;
        }
      }
      if (!Number.isFinite(minVal) || !Number.isFinite(maxVal)) {
        const fallback = { min: 24, max: 36 };
        globalMinMaxCache.set(key, fallback);
        return fallback;
      }
      if (minVal === maxVal) maxVal = minVal + 0.1;
      const res = { min: minVal, max: maxVal };
      globalMinMaxCache.set(key, res);
      return res;
    }

    // --- Color ramp (fixed G→Y→R) ---
    function applyRampGYR() {
      if (!map.getLayer("heat")) return;
      const ramp = ["interpolate", ["linear"], ["heatmap-density"],
        0.00, "rgba(0,255,0,0)",
        0.35, "rgb(0,255,0)",
        0.70, "rgb(255,255,0)",
        0.90, "rgb(255,165,0)",
        1.00, "rgb(255,0,0)"
      ];
      map.setPaintProperty("heat", "heatmap-color", ramp);
    }

    // --- Apply scale (Auto vs Fixed) ---
    async function applyScaleToHeat() {
      if (!map.getLayer("heat")) return;
      let min, max;
      if ($scaleMode.value === "auto") {
        const { min: mi, max: ma } = await getGlobalMinMaxFor(currentTimeStr(), $place.value);
        min = mi; max = ma;
      } else {
        min = Number($fixedMin.value);
        max = Number($fixedMax.value);
        if (!(Number.isFinite(min) && Number.isFinite(max))) { min = 24; max = 36; }
        if (min === max) max = min + 0.1;
      }
      map.setPaintProperty("heat", "heatmap-weight",
        ["interpolate", ["linear"], ["get","value"], min, 0, max, 1]
      );
    }

    // --- Zoom-stable radius (no UI) ---
    function applyRadiusConstant() {
      if (!map.getLayer("heat")) return;
      const r12 = 5;   // px at z12
      const r16 = 24;  // px at z16
      const r10 = Math.max(1, r12 / 4);
      const r19 = Math.min(2048, r16 * 8);
      map.setPaintProperty("heat", "heatmap-radius",
        ["interpolate", ["exponential", 2], ["zoom"],
          10, r10,
          12, r12,
          16, r16,
          19, r19
        ]
      );
    }

    async function applyFilters() {
      const f = buildFilter();
      if (map.getLayer("heat"))   map.setFilter("heat", f);
      if (map.getLayer("points")) map.setFilter("points", f);
      $hourLabel.textContent = `${String($hour.value).padStart(2,"0")}:00`;

      await applyScaleToHeat();
      applyRadiusConstant();
      applyRampGYR();

      if (chart && chart.options?.plugins?.annotation?.annotations?.selectedHour) {
        chart.options.plugins.annotation.annotations.selectedHour.value = currentTimeStr();
        chart.options.plugins.annotation.annotations.selectedHour.label.content = `Hour ${$hour.value}:00`;
        chart.update('none');
      }
    }

    map.on("load", async () => {
      $status.textContent = "ready";

      map.addLayer({
        id: "heat",
        type: "heatmap",
        source: "temps",
        "source-layer": LAYER_NAME,
        minzoom: 0,
        maxzoom: 22,
        paint: {
          "heatmap-weight": ["interpolate", ["linear"], ["get","value"], 24,0, 36,1],
          "heatmap-radius": ["interpolate", ["exponential", 2], ["zoom"], 10,2, 12,5, 16,24, 19,192],
          "heatmap-intensity": 0.9,
          "heatmap-opacity": 0.95,
          "heatmap-color": ["interpolate", ["linear"], ["heatmap-density"],
            0.00, "rgba(0,255,0,0)", 0.35, "rgb(0,255,0)", 0.70, "rgb(255,255,0)", 0.90, "rgb(255,165,0)", 1.00, "rgb(255,0,0)"]
        },
        filter: buildFilter()
      });

      // Invisible picking layer
      map.addLayer({
        id: "points",
        type: "circle",
        source: "temps",
        "source-layer": LAYER_NAME,
        minzoom: 8,
        paint: { "circle-radius": 5, "circle-color": "rgba(0,0,0,0)" },
        filter: buildFilter()
      });

      [$hour, $place, $scaleMode, $fixedMin, $fixedMax].forEach(el => {
        el.addEventListener("input", applyFilters);
        el.addEventListener("change", applyFilters);
      });

      await applyFilters();
    });

    // --- Popup (absolute values; coords) ---
    const popup = new maplibregl.Popup({ closeButton: false, closeOnClick: false });
    map.on("mousemove", (e) => {
      const features = map.queryRenderedFeatures(e.point, { layers: ["points"] });
      if (!features.length) { popup.remove(); return; }
      const f = features[0];
      const { value, time, place } = f.properties;
      const [lng, lat] = f.geometry.coordinates;
      popup.setLngLat(e.lngLat)
        .setHTML(`
          <strong>${Number(value).toFixed(1)}°C</strong>
          <br>${time}${place ? "<br>"+place : ""}
          <br>(${lng.toFixed(5)}, ${lat.toFixed(5)})
        `)
        .addTo(map);
    });

    // --- Click -> chart (pixel_id internal, coord label) ---
    map.on("click", async (e) => {
      const placeFilter = $place.value === "__all__" ? null : $place.value;
      let ft = map.queryRenderedFeatures(e.point, { layers: ["points"] })
                  .filter(f => !placeFilter || f.properties?.place === placeFilter)[0];
      if (!ft) ft = await pickNearbyFeature(e.lngLat.lng, e.lngLat.lat, placeFilter);
      if (!ft) { chartContainer.style.display = "none"; return; }

      const px = ft.properties?.pixel_id;
      if (!px) { chartContainer.style.display = "none"; return; }

      const [lng, lat] = ft.geometry.coordinates;
      const byTime = await loadSeriesByPixelId(px, lng, lat, placeFilter);
      const series = hours24.map(t => byTime.has(t) ? byTime.get(t) : null);
      if (series.filter(v => v != null).length < 2) { chartContainer.style.display = "none"; return; }

      chartContainer.style.display = "block";
      const ctx = document.getElementById("tempChart").getContext("2d");
      if (chart) chart.destroy();
      chart = new Chart(ctx, {
        type: 'line',
        data: { labels: hours24, datasets: [{
          label: `(${lng.toFixed(5)}, ${lat.toFixed(5)})${placeFilter ? " · "+placeFilter : ""}`,
          data: series, borderWidth: 2, pointRadius: 3, spanGaps: true, tension: 0.3
        }]},
        options: {
          responsive: true, maintainAspectRatio: false,
          scales: { x: { ticks: { autoSkip:true, maxTicksLimit:12 } } },
          plugins: { legend: { display:true }, annotation: {
            annotations: { selectedHour: {
              type:'line', scaleID:'x', value: currentTimeStr(),
              borderWidth:2, label:{ content: `Hour ${$hour.value}:00`, enabled:true, position:'start' }
            }}
          }}
        }
      });
    });
  </script>
</body>
</html>

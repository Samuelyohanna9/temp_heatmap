<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>City Temperature Heatmap</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="vendor/maplibre-gl.css" rel="stylesheet" />
  <style>
    html, body { margin: 0; height: 100%; }
    #map { position: absolute; inset: 0; }
    #ui {
      position: absolute; top: 10px; left: 10px; z-index: 10;
      background: #fff; padding: 12px; border-radius: 10px;
      font: 14px/1.25 system-ui, sans-serif;
      box-shadow: 0 4px 20px rgba(0,0,0,.12); width: 320px;
    }
    #ui label { display: block; margin: 8px 0 4px; font-weight: 600; }
    #ui .row { display: flex; gap: 8px; align-items: center; }
    #ui .row input[type=range] { flex: 1; }
    #badge {
      position: absolute; bottom: 10px; left: 10px; z-index: 10;
      background: #fff; padding: 6px 8px; border-radius: 8px;
      font: 12px system-ui, sans-serif; box-shadow: 0 2px 12px rgba(0,0,0,.12);
    }
    #chartContainer {
      position:absolute;top:10px;right:10px;width:360px;height:240px;
      background:#fff;opacity:0.95;padding:10px;border-radius:8px;
      display:none;z-index:20;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div id="ui">
    <div class="row" style="justify-content:space-between;">
      <strong>Temperature Heatmap</strong>
      <span id="status" style="opacity:.7;">loading…</span>
    </div>
    <label for="hour">Hour</label>
    <div class="row">
      <input id="hour" type="range" min="0" max="23" step="1" value="19" />
      <span id="hourLabel" style="width:80px; text-align:right;">19:00</span>
    </div>
    <label for="place">Place</label>
    <select id="place">
      <option value="__all__">All places</option>
      <option value="sparafucile">sparafucile</option>
      <option value="parcote">parcote</option>
    </select>
  </div>

  <div id="badge">Data: PMTiles (Cloudflare R2) · MapLibre GL</div>
  <div id="chartContainer"><canvas id="tempChart"></canvas></div>

  <!-- vendor scripts -->
  <script src="vendor/maplibre-gl.js"></script>
  <script src="vendor/pmtiles.js"></script>
  <script src="vendor/basemaps.js"></script>
  <script src="vendor/pbf.min.js"></script>
  <script src="vendor/vector-tile.js"></script>
  <script src="vendor/chart.umd.js"></script>
  <script src="vendor/chartjs-plugin-annotation.min.js"></script>
  <script>
    if (window['chartjs-plugin-annotation']) Chart.register(window['chartjs-plugin-annotation']);
    else if (window.ChartAnnotation) Chart.register(window.ChartAnnotation);
  </script>

  <script>
    // ---- Config ----
    const PMTILES_BASEMAP = "https://pub-7d28cd0e85994386bd14b8b8fa86a6d7.r2.dev/mantua_basemap.pmtiles";
    const PMTILES_TEMPS   = "https://pub-7d28cd0e85994386bd14b8b8fa86a6d7.r2.dev/all_temps.pmtiles";

    const LAYER_NAME = "temps";
    const DATE = "2025-07-23";
    const INIT_CENTER = [10.80, 45.16];
    const INIT_ZOOM = 12.2;
    const DECODE_ZOOM = 14;

    // note the seconds included
    const hours24 = Array.from({length:24}, (_,i)=> `${DATE}T${String(i).padStart(2,"0")}:00:00`);

    // ---- UI refs ----
    const $status = document.getElementById("status");
    const $hour = document.getElementById("hour");
    const $hourLabel = document.getElementById("hourLabel");
    const $place = document.getElementById("place");
    const chartContainer = document.getElementById("chartContainer");
    let chart = null;

    function currentTimeStr() {
      return `${DATE}T${String($hour.value).padStart(2,"0")}:00:00`;
    }

    // ---- PMTiles protocol ----
    const protocol = new pmtiles.Protocol();
    maplibregl.addProtocol("pmtiles", protocol.tile);
    const archiveTemps = new pmtiles.PMTiles(PMTILES_TEMPS);
    const archiveBase  = new pmtiles.PMTiles(PMTILES_BASEMAP);
    protocol.add(archiveTemps);
    protocol.add(archiveBase);

    // ---- Helpers (decode etc.) ----
    function lonlatToTile(lon, lat, z) {
      const x = Math.floor(((lon + 180) / 360) * Math.pow(2, z));
      const y = Math.floor(
        (1 - Math.log(Math.tan(lat * Math.PI/180) + 1/Math.cos(lat * Math.PI/180)) / Math.PI) / 2 * Math.pow(2, z)
      );
      return { x, y };
    }
    function wrap(n, mod) { return ((n % mod) + mod) % mod; }

    async function decodeTileToPoints(z, x, y) {
      try {
        const resp = await archiveTemps.getZxy(z, x, y);
        if (!resp || !resp.data) return [];
        const vt = new window.vectorTile.VectorTile(new window.Pbf(new Uint8Array(resp.data)));
        const layer = vt.layers[LAYER_NAME];
        if (!layer) return [];
        const feats = [];
        for (let i=0; i<layer.length; i++) {
          const f = layer.feature(i).toGeoJSON(x, y, z);
          if (f.geometry?.type === "Point") feats.push(f);
        }
        return feats;
      } catch (err) {
        console.warn("decodeTileToPoints failed:", err);
        return [];
      }
    }

    async function decodeNeighborhood(lon, lat, z=DECODE_ZOOM) {
      const { x, y } = lonlatToTile(lon, lat, z);
      const max = Math.pow(2, z);
      const coords = [];
      for (let dx=-1; dx<=1; dx++) for (let dy=-1; dy<=1; dy++)
        coords.push([wrap(x+dx,max), wrap(y+dy,max)]);
      const chunks = await Promise.all(coords.map(([tx,ty]) => decodeTileToPoints(z, tx, ty)));
      return chunks.flat();
    }

    async function findNearestFeature(lon, lat, placeFilter) {
      const all = await decodeNeighborhood(lon, lat, DECODE_ZOOM);
      const filtered = placeFilter ? all.filter(g => g.properties?.place === placeFilter) : all;
      let best = null, bestD2 = Infinity;
      for (const g of filtered) {
        const [gx, gy] = g.geometry.coordinates;
        const dx = (gx - lon), dy = (gy - lat);
        const d2 = dx*dx + dy*dy;
        if (d2 < bestD2) { best = g; bestD2 = d2; }
      }
      return best;
    }

    async function loadTimeseriesById(sensorId, lonHint, latHint, placeFilter) {
      const all = await decodeNeighborhood(lonHint, latHint, DECODE_ZOOM);
      const rows = all.filter(f => String(f.properties?.id) === String(sensorId) &&
                                   (!placeFilter || f.properties?.place === placeFilter));
      const map = new Map();
      for (const f of rows) {
        const p = f.properties || {};
        if (p.time && typeof p.value !== "undefined") {
          map.set(p.time, Number(p.value));
        }
      }
      return map;
    }

    // ---- Style ----
    const basemapSourceId = "basemap";
    const style = {
      version: 8,
      glyphs: "https://protomaps.github.io/basemaps-assets/fonts/{fontstack}/{range}.pbf",
      sprite: "https://protomaps.github.io/basemaps-assets/sprites/v4/light",
      sources: {
        [basemapSourceId]: {
          type: "vector",
          url: "pmtiles://" + PMTILES_BASEMAP,
          minzoom: 0,
          maxzoom: 14,
          attribution: '<a href="https://protomaps.com">Protomaps</a> © <a href="https://openstreetmap.org">OpenStreetMap</a>'
        },
        temps: {
          type: "vector",
          url: "pmtiles://" + PMTILES_TEMPS,
          minzoom: 8
        }
      },
      layers: (window.basemaps
        ? window.basemaps.layers(basemapSourceId, window.basemaps.namedFlavor("light"), { lang: "en" })
        : [{ id:"bg", type:"background", paint:{ "background-color":"#f3f4f6" }}])
    };

    // ---- Map ----
    const map = new maplibregl.Map({
      container: "map",
      style,
      center: INIT_CENTER,
      zoom: INIT_ZOOM,
      maxZoom: 22
    });

    map.addControl(new maplibregl.NavigationControl(), "top-right");
    map.addControl(new maplibregl.ScaleControl({ unit: "metric" }));
    map.on("error", (e) => console.error("Map error:", e?.error || e));

    function buildFilter() {
      const timeFilter = ["==", ["get","time"], currentTimeStr()];
      const p = $place.value;
      return (p === "__all__") ? timeFilter : ["all", timeFilter, ["==", ["get","place"], p]];
    }

    function applyFilters() {
      const f = buildFilter();
      if (map.getLayer("heat"))   map.setFilter("heat", f);
      if (map.getLayer("points")) map.setFilter("points", f);
      $hourLabel.textContent = `${String($hour.value).padStart(2,"0")}:00`;
      if (chart && chart.options?.plugins?.annotation?.annotations?.selectedHour) {
        chart.options.plugins.annotation.annotations.selectedHour.value = currentTimeStr();
        chart.options.plugins.annotation.annotations.selectedHour.label.content = `Hour ${$hour.value}:00`;
        chart.update('none');
      }
    }

    map.on("load", () => {
      $status.textContent = "ready";
      map.addLayer({
        id: "heat",
        type: "heatmap",
        source: "temps",
        "source-layer": LAYER_NAME,
        paint: {
          "heatmap-weight": ["interpolate", ["linear"], ["get","value"], 24,0,36,1],
          "heatmap-radius": ["interpolate", ["linear"], ["zoom"], 8,6,10,10,12,18,14,26,16,30],
          "heatmap-intensity": 0.5,
          "heatmap-opacity": 0.9,
          "heatmap-color": ["interpolate", ["linear"], ["heatmap-density"],
            0.0, "rgba(0,255,0,0)",
            0.3, "rgb(0,255,0)",
            0.6, "rgb(255,255,0)",
            1.0, "rgb(255,0,0)"
          ]
        },
        filter: buildFilter()
      });
      map.addLayer({
        id: "points",
        type: "circle",
        source: "temps",
        "source-layer": LAYER_NAME,
        minzoom: 8,
        paint: { "circle-radius": 5, "circle-color": "rgba(0,0,0,0)" },
        filter: buildFilter()
      });
      $hour.addEventListener("input", applyFilters);
      $place.addEventListener("change", applyFilters);
      applyFilters();
    });

    // Hover popup
    let popup = new maplibregl.Popup({ closeButton: false, closeOnClick: false });
    map.on("mousemove", (e) => {
      const features = map.queryRenderedFeatures(e.point, { layers: ["points"] });
      if (!features.length) { popup.remove(); return; }
      const f = features[0];
      const { id, value, time, place } = f.properties;
      popup.setLngLat(e.lngLat)
        .setHTML(`<strong>${Number(value).toFixed(1)}°C</strong><br>${time}${place ? "<br>"+place : ""}<br>ID: ${id}`)
        .addTo(map);
    });

    // Click -> build series by sensor id
    map.on("click", async (e) => {
      try {
        const placeFilter = $place.value === "__all__" ? null : $place.value;
        let ft = map.queryRenderedFeatures(e.point, { layers: ["points"] })
                    .filter(f => !placeFilter || f.properties?.place === placeFilter)[0];
        if (!ft) {
          const nearest = await findNearestFeature(e.lngLat.lng, e.lngLat.lat, placeFilter);
          if (!nearest) { chartContainer.style.display = "none"; return; }
          ft = nearest;
        }
        const sensorId = ft.properties?.id;
        if (typeof sensorId === "undefined") { chartContainer.style.display = "none"; return; }
        const [lng, lat] = ft.geometry.coordinates;
        const byTime = await loadTimeseriesById(sensorId, lng, lat, placeFilter);
        const series = hours24.map(t => byTime.has(t) ? byTime.get(t) : null);
        chartContainer.style.display = "block";
        const ctx = document.getElementById("tempChart").getContext("2d");
        if (chart) chart.destroy();
        chart = new Chart(ctx, {
          type: 'line',
          data: { labels: hours24, datasets: [{
            label: `Sensor ${sensorId}${placeFilter ? " · "+placeFilter : ""}`,
            data: series, borderWidth: 2, pointRadius: 3, spanGaps: true, tension: 0.3
          }]},
          options: {
            responsive: true, maintainAspectRatio: false,
            scales: { x: { ticks: { autoSkip:true, maxTicksLimit:12 } } },
            plugins: { legend: { display:true }, annotation: {
              annotations: { selectedHour: {
                type:'line', scaleID:'x', value: currentTimeStr(),
                borderWidth:2, label:{ content: `Hour ${$hour.value}:00`, enabled:true, position:'start' }
              }}
            }}
          }
        });
      } catch (err) {
        console.error("Click/id-series error:", err);
        chartContainer.style.display = "none";
      }
    });
  </script>
</body>
</html>

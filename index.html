<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>City Temperature Heatmap</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="vendor/maplibre-gl.css" rel="stylesheet" />
  <style>
    html, body { margin: 0; height: 100%; }
    #map { position: absolute; inset: 0; }
    #ui {
      position: absolute; top: 10px; left: 10px; z-index: 10;
      background: #fff; padding: 12px; border-radius: 10px;
      font: 14px/1.25 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      box-shadow: 0 4px 20px rgba(0,0,0,.12); width: 320px;
    }
    #ui label { display: block; margin: 8px 0 4px; font-weight: 600; }
    #ui .row { display: flex; gap: 8px; align-items: center; }
    #ui .row input[type=range] { flex: 1; }
    #badge {
      position: absolute; bottom: 10px; left: 10px; z-index: 10;
      background: #fff; padding: 6px 8px; border-radius: 8px;
      font: 12px system-ui, sans-serif; box-shadow: 0 2px 12px rgba(0,0,0,.12);
    }
    #chartContainer {
      position:absolute; top:10px; right:10px; width:360px; height:240px;
      background:#fff; opacity:0.95; padding:10px; border-radius:8px;
      display:none; z-index:20;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div id="ui">
    <div class="row" style="justify-content:space-between;">
      <strong>Temperature Heatmap</strong>
      <span id="status" style="opacity:.7;">loading…</span>
    </div>

    <label for="hour">Hour</label>
    <div class="row">
      <input id="hour" type="range" min="0" max="23" step="1" value="19" />
      <span id="hourLabel" style="width:80px; text-align:right;">19:00</span>
    </div>

    <label for="place">Place</label>
    <select id="place">
      <option value="__all__">All places</option>
      <option value="sparafucile">sparafucile</option>
      <option value="parcote">parcote</option>
    </select>
  </div>

  <div id="badge">Data: PMTiles (Cloudflare R2) · MapLibre GL</div>
  <div id="chartContainer"><canvas id="tempChart"></canvas></div>

  <script src="vendor/maplibre-gl.js"></script>
  <script src="vendor/pmtiles.js"></script>
  <script src="vendor/basemaps.js"></script>
  <script src="vendor/pbf.min.js"></script>
  <script src="vendor/vector-tile.js"></script>
  <script src="vendor/chart.umd.js"></script>
  <script src="vendor/chartjs-plugin-annotation.min.js"></script>
  <script>
    if (window['chartjs-plugin-annotation']) Chart.register(window['chartjs-plugin-annotation']);
    else if (window.ChartAnnotation) Chart.register(window.ChartAnnotation);
  </script>

  <script>
    // --- Config ---
    const PMTILES_BASEMAP = "https://pub-7d28cd0e85994386bd14b8b8fa86a6d7.r2.dev/mantua_basemap.pmtiles";
    const PMTILES_TEMPS   = "https://pub-7d28cd0e85994386bd14b8b8fa86a6d7.r2.dev/all_temps.pmtiles";
    const LAYER_NAME = "temps";
    const DATE = "2025-07-23";
    const INIT_CENTER = [10.80, 45.16];
    const INIT_ZOOM = 12.2;
    const DECODE_ZOOM = 14;
    const CLICK_MAX_M = 60;
    const DATA_BOUNDS = [10.785482, 45.145304, 10.814915, 45.167814];

    const hours24 = Array.from({length:24}, (_,i)=> `${DATE}T${String(i).padStart(2,"0")}:00`);
    const currentTimeStr = () => `${DATE}T${String($hour.value).padStart(2,"0")}:00`;

    // --- DOM refs ---
    const $status = document.getElementById("status");
    const $hour = document.getElementById("hour");
    const $hourLabel = document.getElementById("hourLabel");
    const $place = document.getElementById("place");
    const chartContainer = document.getElementById("chartContainer");
    let chart = null;

    // --- PMTiles protocol ---
    const protocol = new pmtiles.Protocol();
    maplibregl.addProtocol("pmtiles", protocol.tile);
    const archiveTemps = new pmtiles.PMTiles(PMTILES_TEMPS);
    const archiveBase  = new pmtiles.PMTiles(PMTILES_BASEMAP);
    protocol.add(archiveTemps);
    protocol.add(archiveBase);

    // --- Helpers ---
    function lonlatToTile(lon, lat, z) {
      const x = Math.floor(((lon + 180) / 360) * Math.pow(2, z));
      const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI/180) + 1/Math.cos(lat * Math.PI/180)) / Math.PI) / 2 * Math.pow(2, z));
      return { x, y };
    }
    const wrap = (n, mod) => ((n % mod) + mod) % mod;
    function haversine(lon1, lat1, lon2, lat2) {
      const R = 6371000, toRad = d => d*Math.PI/180;
      const dLat = toRad(lat2-lat1), dLon = toRad(lon2-lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(a));
    }

    async function decodeTileToPoints(z, x, y) {
      try {
        const resp = await archiveTemps.getZxy(z, x, y);
        if (!resp || !resp.data) return [];
        const vt = new window.vectorTile.VectorTile(new window.Pbf(new Uint8Array(resp.data)));
        const layer = vt.layers[LAYER_NAME];
        if (!layer) return [];
        const feats = [];
        for (let i=0; i<layer.length; i++) {
          const f = layer.feature(i).toGeoJSON(x, y, z);
          if (f.geometry?.type === "Point") feats.push(f);
        }
        return feats;
      } catch { return []; }
    }

    async function decodeBoundsToPoints(bounds = DATA_BOUNDS, z = DECODE_ZOOM) {
      const [minLon, minLat, maxLon, maxLat] = bounds;
      const tl = lonlatToTile(minLon, maxLat, z);
      const br = lonlatToTile(maxLon, minLat, z);
      const n = Math.pow(2, z);
      const xMin = Math.max(0, Math.min(tl.x, br.x));
      const xMax = Math.min(n - 1, Math.max(tl.x, br.x));
      const yMin = Math.max(0, Math.min(tl.y, br.y));
      const yMax = Math.min(n - 1, Math.max(tl.y, br.y));
      const promises = [];
      for (let x = xMin; x <= xMax; x++) {
        for (let y = yMin; y <= yMax; y++) {
          promises.push(decodeTileToPoints(z, x, y));
        }
      }
      const chunks = await Promise.all(promises);
      return chunks.flat();
    }

    async function pickNearbyFeature(lon, lat, placeFilter) {
      const { x, y } = lonlatToTile(lon, lat, DECODE_ZOOM);
      const n = Math.pow(2, DECODE_ZOOM);
      const coords = [];
      for (let dx=-1; dx<=1; dx++) for (let dy=-1; dy<=1; dy++) coords.push([wrap(x+dx,n), wrap(y+dy,n)]);
      const chunks = await Promise.all(coords.map(([tx,ty]) => decodeTileToPoints(DECODE_ZOOM, tx, ty)));
      const all = chunks.flat();
      const filtered = placeFilter ? all.filter(g => g.properties?.place === placeFilter) : all;
      let best = null, bestD = Infinity;
      for (const g of filtered) {
        const [gx, gy] = g.geometry.coordinates;
        const d = haversine(lon, lat, gx, gy);
        if (d < bestD) { best = g; bestD = d; }
      }
      return (best && bestD <= CLICK_MAX_M) ? best : null;
    }

    async function loadSeriesByPixelId(pixelId, lonHint, latHint, placeFilter) {
      const { x, y } = lonlatToTile(lonHint, latHint, DECODE_ZOOM);
      const n = Math.pow(2, DECODE_ZOOM);
      const coords = [];
      for (let dx=-1; dx<=1; dx++) for (let dy=-1; dy<=1; dy++) coords.push([wrap(x+dx,n), wrap(y+dy,n)]);
      const chunks = await Promise.all(coords.map(([tx,ty]) => decodeTileToPoints(DECODE_ZOOM, tx, ty)));
      const all = chunks.flat();
      const rows = all.filter(f =>
        String(f.properties?.pixel_id) === String(pixelId) &&
        (!placeFilter || f.properties?.place === placeFilter)
      );
      const m = new Map();
      for (const f of rows) {
        const p = f.properties || {};
        if (p.time && typeof p.value !== "undefined") m.set(p.time, Number(p.value));
      }
      return m;
    }

    // --- Map style ---
    const basemapSourceId = "basemap";
    const style = {
      version: 8,
      // Disable global transitions to avoid zoom “fade”
      transition: { duration: 0, delay: 0 },
      glyphs: "https://protomaps.github.io/basemaps-assets/fonts/{fontstack}/{range}.pbf",
      sprite: "https://protomaps.github.io/basemaps-assets/sprites/v4/light",
      sources: {
        [basemapSourceId]: {
          type: "vector",
          url: "pmtiles://" + PMTILES_BASEMAP,
          minzoom: 0, maxzoom: 14,
          attribution: '<a href="https://protomaps.com">Protomaps</a> © <a href="https://openstreetmap.org">OpenStreetMap</a>'
        },
        temps: { type: "vector", url: "pmtiles://" + PMTILES_TEMPS, minzoom: 8, maxzoom: 22 }
      },
      layers: (window.basemaps
        ? window.basemaps.layers(basemapSourceId, window.basemaps.namedFlavor("light"), { lang: "en" })
        : [{ id:"bg", type:"background", paint:{ "background-color":"#f3f4f6" }}])
    };

    // --- Per-hour & per-place global min/max cache ---
    const globalMinMaxCache = new Map();
    async function getGlobalMinMaxFor(hourStr, placeValue) {
      const key = `${hourStr}|${placeValue}`;
      if (globalMinMaxCache.has(key)) return globalMinMaxCache.get(key);

      const all = await decodeBoundsToPoints(DATA_BOUNDS, DECODE_ZOOM);
      const filtered = all.filter(f =>
        f.properties?.time === hourStr &&
        (placeValue === "__all__" || f.properties?.place === placeValue)
      );

      if (!filtered.length) {
        const fallback = { min: 24, max: 36 };
        globalMinMaxCache.set(key, fallback);
        return fallback;
      }

      let minVal = Infinity, maxVal = -Infinity;
      for (const f of filtered) {
        const v = Number(f.properties?.value);
        if (Number.isFinite(v)) {
          if (v < minVal) minVal = v;
          if (v > maxVal) maxVal = v;
        }
      }
      if (!Number.isFinite(minVal) || !Number.isFinite(maxVal)) {
        const fallback = { min: 24, max: 36 };
        globalMinMaxCache.set(key, fallback);
        return fallback;
      }
      if (minVal === maxVal) maxVal = minVal + 0.1; // avoid degenerate scale

      const res = { min: minVal, max: maxVal };
      globalMinMaxCache.set(key, res);
      return res;
    }

    async function applyGlobalHeatScale() {
      if (!map.getLayer("heat")) return;
      const hourStr = currentTimeStr();
      const placeValue = $place.value; // "__all__" or a place
      const { min, max } = await getGlobalMinMaxFor(hourStr, placeValue);
      map.setPaintProperty("heat", "heatmap-weight", [
        "interpolate", ["linear"], ["get","value"],
        min, 0,
        max, 1
      ]);
    }

    function buildFilter() {
      const timeFilter = ["==", ["get","time"], currentTimeStr()];
      const p = $place.value;
      return (p === "__all__") ? timeFilter : ["all", timeFilter, ["==", ["get","place"], p]];
    }

    async function applyFilters() {
      const f = buildFilter();
      if (map.getLayer("heat"))   map.setFilter("heat", f);
      if (map.getLayer("points")) map.setFilter("points", f);
      $hourLabel.textContent = `${String($hour.value).padStart(2,"0")}:00`;

      await applyGlobalHeatScale();

      if (chart && chart.options?.plugins?.annotation?.annotations?.selectedHour) {
        chart.options.plugins.annotation.annotations.selectedHour.value = currentTimeStr();
        chart.options.plugins.annotation.annotations.selectedHour.label.content = `Hour ${$hour.value}:00`;
        chart.update('none');
      }
    }

    // --- Map init (fadeDuration=0 removes tile cross-fade) ---
    const map = new maplibregl.Map({
      container: "map",
      style,
      center: INIT_CENTER,
      zoom: INIT_ZOOM,
      maxZoom: 22,
      fadeDuration: 0
    });
    map.addControl(new maplibregl.NavigationControl(), "top-right");
    map.addControl(new maplibregl.ScaleControl({ unit: "metric" }));
    map.on("error", (e) => console.error("Map error:", e?.error || e));

    map.on("load", () => {
      $status.textContent = "ready";

      // --- Heat layer (robust visibility; no bad transition key) ---
      map.addLayer({
        id: "heat",
        type: "heatmap",
        source: "temps",
        "source-layer": LAYER_NAME,
        paint: {
          // baseline; applyGlobalHeatScale() overwrites per hour/place
          "heatmap-weight": ["interpolate", ["linear"], ["get","value"], 24,0, 36,1],

          // Kernel size with zoom (tuned to keep cohesion w/o over-smoothing)
          "heatmap-radius": ["interpolate", ["exponential", 1.6], ["zoom"],
            8, 20,
            12, 48,
            14, 72,
            16, 120,
            18, 180
          ],

          // Modest intensity growth with zoom
          "heatmap-intensity": ["interpolate", ["exponential", 1.2], ["zoom"],
            8, 1.1,
            12, 1.8,
            14, 2.6,
            16, 3.5,
            18, 4.2
          ],

          // Keep fully opaque
          "heatmap-opacity": 1,

          // Lower visibility threshold so low densities still render
          "heatmap-color": ["interpolate", ["linear"], ["heatmap-density"],
            0.00, "rgba(0,0,0,0)",
            0.12, "rgba(255,255,128,0.75)",
            0.35, "rgb(255,180,0)",
            0.65, "rgb(255,96,0)",
            1.00, "rgb(255,0,0)"
          ],

          // Valid transitions only
          "heatmap-opacity-transition":   { duration: 0, delay: 0 },
          "heatmap-radius-transition":    { duration: 0, delay: 0 },
          "heatmap-intensity-transition": { duration: 0, delay: 0 }
        },
        filter: buildFilter()
      });

      // --- Invisible points for hover/click (hit-testing only) ---
      map.addLayer({
        id: "points",
        type: "circle",
        source: "temps",
        "source-layer": LAYER_NAME,
        minzoom: 8,
        paint: {
          "circle-opacity": 0,
          "circle-stroke-opacity": 0
        },
        filter: buildFilter()
      });

      $hour.addEventListener("input", applyFilters);
      $place.addEventListener("change", applyFilters);
      applyFilters();
    });

    // --- Popup (absolute °C; coords) ---
    const popup = new maplibregl.Popup({ closeButton: false, closeOnClick: false });
    map.on("mousemove", (e) => {
      const features = map.queryRenderedFeatures(e.point, { layers: ["points"] });
      if (!features.length) { popup.remove(); return; }
      const f = features[0];
      const { value, time, place } = f.properties || {};
      const [lng, lat] = f.geometry.coordinates;
      popup.setLngLat(e.lngLat)
        .setHTML(`
          <strong>${Number(value).toFixed(1)}°C</strong>
          <br>${time || ""}${place ? "<br>"+place : ""}
          <br>(${lng.toFixed(5)}, ${lat.toFixed(5)})
        `)
        .addTo(map);
    });

    // --- Click -> chart (pixel_id internal, coord label) ---
    map.on("click", async (e) => {
      const placeFilter = $place.value === "__all__" ? null : $place.value;
      let ft = map.queryRenderedFeatures(e.point, { layers: ["points"] })
                  .filter(f => !placeFilter || f.properties?.place === placeFilter)[0];
      if (!ft) ft = await pickNearbyFeature(e.lngLat.lng, e.lngLat.lat, placeFilter);
      if (!ft) { chartContainer.style.display = "none"; return; }

      const px = ft.properties?.pixel_id;
      if (!px) { chartContainer.style.display = "none"; return; }

      const [lng, lat] = ft.geometry.coordinates;
      const byTime = await loadSeriesByPixelId(px, lng, lat, placeFilter);
      const series = hours24.map(t => byTime.has(t) ? byTime.get(t) : null);
      if (series.filter(v => v != null).length < 2) { chartContainer.style.display = "none"; return; }

      chartContainer.style.display = "block";
      const ctx = document.getElementById("tempChart").getContext("2d");
      if (chart) chart.destroy();
      chart = new Chart(ctx, {
        type: 'line',
        data: { labels: hours24, datasets: [{
          label: `(${lng.toFixed(5)}, ${lat.toFixed(5)})${placeFilter ? " · "+placeFilter : ""}`,
          data: series, borderWidth: 2, pointRadius: 3, spanGaps: true, tension: 0.3
        }]},
        options: {
          responsive: true, maintainAspectRatio: false,
          scales: { x: { ticks: { autoSkip:true, maxTicksLimit:12 } } },
          plugins: { legend: { display:true }, annotation: {
            annotations: { selectedHour: {
              type:'line', scaleID:'x', value: currentTimeStr(),
              borderWidth:2, label:{ content: `Hour ${$hour.value}:00`, enabled:true, position:'start' }
            }}
          }}
        }
      });
    });
  </script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>City Temperature Heatmap</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    html, body { margin: 0; height: 100%; }
    #map { position: absolute; inset: 0; }
    #ui {
      position: absolute; top: 10px; left: 10px; z-index: 10;
      background: #fff; padding: 12px; border-radius: 10px;
      font: 14px/1.25 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      box-shadow: 0 4px 20px rgba(0,0,0,.12); width: 320px;
    }
    #ui label { display: block; margin: 8px 0 4px; font-weight: 600; }
    #ui .row { display: flex; gap: 8px; align-items: center; }
    #ui .row input[type=range] { flex: 1; }
    #badge {
      position: absolute; bottom: 10px; left: 10px; z-index: 10;
      background: #fff; padding: 6px 8px; border-radius: 8px;
      font: 12px system-ui, sans-serif; box-shadow: 0 2px 12px rgba(0,0,0,.12);
    }
    #chartContainer {
      position:absolute;top:10px;right:10px;width:360px;height:240px;
      background:#fff;opacity:0.95;padding:10px;border-radius:8px;
      display:none;z-index:20;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div id="ui">
    <div class="row" style="justify-content:space-between;">
      <strong>Temperature Heatmap</strong>
      <span id="status" style="opacity:.7;">loading…</span>
    </div>

    <label for="hour">Hour</label>
    <div class="row">
      <input id="hour" type="range" min="0" max="23" step="1" value="19" />
      <span id="hourLabel" style="width:80px; text-align:right;">19:00</span>
    </div>

    <label for="radius">Heatmap radius</label>
    <div class="row">
      <input id="radius" type="range" min="5" max="50" step="1" value="26" />
      <span id="radiusLabel" style="width:36px; text-align:right;">26</span>
    </div>

    <label for="intensity">Heatmap intensity</label>
    <div class="row">
      <input id="intensity" type="range" min="0.1" max="3" step="0.1" value="1.0" />
      <span id="intensityLabel" style="width:36px; text-align:right;">1.0</span>
    </div>
  </div>

  <div id="badge">Data: PMTiles from Cloudflare R2 · Styled with MapLibre GL</div>
  <div id="chartContainer"><canvas id="tempChart"></canvas></div>

  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0"></script>

  <script type="module">
    import * as pmtiles from "https://unpkg.com/pmtiles@3.0.7/dist/index.js";
    import Pbf from "https://esm.sh/pbf@3.2.1";
    import { VectorTile } from "https://esm.sh/@mapbox/vector-tile@1.3.1";

    // Map + PMTiles
    const protocol = new pmtiles.Protocol();
    maplibregl.addProtocol("pmtiles", protocol.tile);

    const PMTILES_URL = "https://pub-7d28cd0e85994386bd14b8b8fa86a6d7.r2.dev/all_temps.pmtiles";
    const archive = new pmtiles.PMTiles(PMTILES_URL);

    // Config
    const LAYER_NAME = "temps";
    const DATE = "2025-07-23";
    const INIT_CENTER = [10.80, 45.16];
    const INIT_ZOOM = 12.2;
    const DECODE_ZOOM = 14;      // fixed decode zoom
    const EPS = 1e-5;            // coordinate match tolerance in degrees (~1 m)
    const hours24 = Array.from({length:24}, (_,i)=> `${DATE}T${String(i).padStart(2,"0")}:00`);

    // UI refs
    const $status = document.getElementById("status");
    const $hour = document.getElementById("hour");
    const $hourLabel = document.getElementById("hourLabel");
    const $radius = document.getElementById("radius");
    const $radiusLabel = document.getElementById("radiusLabel");
    const $intensity = document.getElementById("intensity");
    const $intensityLabel = document.getElementById("intensityLabel");
    const chartContainer = document.getElementById("chartContainer");
    let chart = null;

    function currentTimeStr() {
      return `${DATE}T${String($hour.value).padStart(2,"0")}:00`;
    }

    // Slippy helpers
    function lonlatToTile(lon, lat, z) {
      const x = Math.floor(((lon + 180) / 360) * Math.pow(2, z));
      const y = Math.floor(
        (1 - Math.log(Math.tan(lat * Math.PI/180) + 1/Math.cos(lat * Math.PI/180)) / Math.PI) / 2 * Math.pow(2, z)
      );
      return { x, y };
    }
    function wrap(n, mod) { return ((n % mod) + mod) % mod; }

    // Haversine distance (meters)
    function haversine(lon1, lat1, lon2, lat2) {
      const R = 6371000;
      const toRad = d => d * Math.PI/180;
      const dLat = toRad(lat2-lat1), dLon = toRad(lon2-lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(a));
    }

    // Decode one tile and return all GeoJSON point features
    function decodeTileToPoints(z, x, y) {
      return archive.getZxy(z, x, y).then(resp => {
        if (!resp || !resp.data) return [];
        const vt = new VectorTile(new Pbf(new Uint8Array(resp.data)));
        const layer = vt.layers[LAYER_NAME];
        if (!layer) return [];
        const feats = [];
        for (let i=0; i<layer.length; i++) {
          const f = layer.feature(i).toGeoJSON(x, y, z);
          if (f.geometry?.type === "Point") feats.push(f);
        }
        return feats;
      }).catch(() => []);
    }

    // Find nearest feature to lon/lat by decoding clicked tile + 8 neighbors at DECODE_ZOOM
    async function findNearestFeature(lon, lat) {
      const { x, y } = lonlatToTile(lon, lat, DECODE_ZOOM);
      const max = Math.pow(2, DECODE_ZOOM);
      const coords = [];
      for (let dx=-1; dx<=1; dx++) for (let dy=-1; dy<=1; dy++)
        coords.push([wrap(x+dx,max), wrap(y+dy,max)]);
      const chunks = await Promise.all(coords.map(([tx,ty]) => decodeTileToPoints(DECODE_ZOOM, tx, ty)));
      const all = chunks.flat();
      let best = null, bestD = Infinity;
      for (const g of all) {
        const [gx, gy] = g.geometry.coordinates;
        const d = haversine(lon, lat, gx, gy);
        if (d < bestD) { best = g; bestD = d; }
      }
      return best; // may be null if empty
    }

    // Build timeseries map for the exact coordinate (matches all hours at that point)
    async function loadTimeseriesAtCoord(lon, lat) {
      const { x, y } = lonlatToTile(lon, lat, DECODE_ZOOM);
      const pts = await decodeTileToPoints(DECODE_ZOOM, x, y);
      const map = new Map();
      for (const f of pts) {
        const [fx, fy] = f.geometry.coordinates;
        const t = f.properties?.time;
        const v = f.properties?.value;
        if (t && typeof v !== "undefined" && Math.abs(fx-lon) < EPS && Math.abs(fy-lat) < EPS) {
          map.set(t, Number(v));
        }
      }
      return map;
    }

    // Map
    const map = new maplibregl.Map({
      container: "map",
      center: INIT_CENTER,
      zoom: INIT_ZOOM,
      style: {
        version: 8,
        sources: {
          basemap: {
            type: "raster",
            tiles: ["https://tile.openstreetmap.org/{z}/{x}/{y}.png"],
            tileSize: 256
          },
          temps: {
            type: "vector",
            url: `pmtiles://${PMTILES_URL}`,
            minzoom: 8
          }
        },
        layers: [
          { id: "basemap", type: "raster", source: "basemap" },
          {
            id: "heat",
            type: "heatmap",
            source: "temps",
            "source-layer": LAYER_NAME,
            minzoom: 8,
            paint: {
              "heatmap-weight": ["interpolate", ["linear"], ["get", "value"], 24, 0, 36, 1],
              "heatmap-radius": 26,
              "heatmap-intensity": 1.0,
              "heatmap-opacity": 0.9,
              "heatmap-color": [
                "interpolate", ["linear"], ["heatmap-density"],
                0.0, "rgba(0,255,0,0)",
                0.3, "rgb(0,255,0)",
                0.6, "rgb(255,255,0)",
                1.0, "rgb(255,0,0)"
              ]
            },
            filter: ["==", ["get", "time"], `${DATE}T19:00`]
          },
          {
            id: "points",
            type: "circle",
            source: "temps",
            "source-layer": LAYER_NAME,
            minzoom: 8,
            paint: {
              "circle-radius": ["interpolate", ["linear"], ["zoom"], 8, 8, 12, 5, 16, 3],
              "circle-color": "rgba(0,0,0,0)",
              "circle-stroke-width": 0,
              "circle-stroke-color": "rgba(0,0,0,0)"
            },
            filter: ["==", ["get", "time"], `${DATE}T19:00`]
          }
        ]
      }
    });

    function applyFilters() {
      const timeFilter = ["==", ["get", "time"], currentTimeStr()];
      map.setFilter("heat", timeFilter);
      map.setFilter("points", timeFilter);
      $hourLabel.textContent = `${String($hour.value).padStart(2,"0")}:00`;

      if (chart) {
        chart.options.plugins.annotation.annotations.selectedHour.value = currentTimeStr();
        chart.options.plugins.annotation.annotations.selectedHour.label.content = `Hour ${$hour.value}:00`;
        chart.update('none');
      }
    }
    function applyPaint() {
      map.setPaintProperty("heat", "heatmap-radius", Number($radius.value));
      map.setPaintProperty("heat", "heatmap-intensity", Number($intensity.value));
      $radiusLabel.textContent = $radius.value;
      $intensityLabel.textContent = $intensity.value;
    }

    $hour.addEventListener("input", applyFilters);
    $radius.addEventListener("input", applyPaint);
    $intensity.addEventListener("input", applyPaint);

    map.on("load", () => {
      $status.textContent = "ready";
      applyFilters();
      applyPaint();
    });

    // Hover popup (fast, uses rendered points)
    let popup = new maplibregl.Popup({ closeButton: false, closeOnClick: false });
    map.on("mousemove", (e) => {
      const features = map.queryRenderedFeatures(e.point, { layers: ["points"] });
      if (!features.length) { popup.remove(); return; }
      const f = features[0];
      const { value, time } = f.properties;
      popup.setLngLat(e.lngLat)
        .setHTML(`<strong>${Number(value).toFixed(1)}°C</strong><br>${time}`)
        .addTo(map);
    });

    // Click: prefer rendered point; if none, find nearest by decoding tiles; then build 24h series at that exact coord
    map.on("click", async (e) => {
      try {
        let features = map.queryRenderedFeatures(e.point, { layers: ["points"] });
        let seedCoord;

        if (features.length) {
          seedCoord = features[0].geometry.coordinates; // [lng, lat]
        } else {
          // Fallback: find nearest feature to click, independent of zoom/viewport
          const nearest = await findNearestFeature(e.lngLat.lng, e.lngLat.lat);
          if (!nearest) { chartContainer.style.display = "none"; return; }
          seedCoord = nearest.geometry.coordinates;
        }

        const [lng, lat] = seedCoord;
        const byTime = await loadTimeseriesAtCoord(lng, lat);

        const series = hours24.map(t => byTime.has(t) ? byTime.get(t) : null);

        chartContainer.style.display = "block";
        const ctx = document.getElementById("tempChart").getContext("2d");
        if (chart) chart.destroy();

        chart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: hours24,
            datasets: [{
              label: `Temperature at [${lng.toFixed(5)}, ${lat.toFixed(5)}]`,
              data: series,
              borderColor: 'rgb(255,0,0)',
              backgroundColor: 'rgba(255,0,0,0.15)',
              borderWidth: 2,
              pointRadius: 3,
              spanGaps: true,
              tension: 0.3
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: { x: { ticks: { autoSkip: true, maxTicksLimit: 12 } } },
            plugins: {
              legend: { display: true },
              annotation: {
                annotations: {
                  selectedHour: {
                    type: 'line',
                    scaleID: 'x',
                    value: currentTimeStr(),
                    borderColor: 'blue',
                    borderWidth: 2,
                    label: { content: `Hour ${$hour.value}:00`, enabled: true, position: 'start' }
                  }
                }
              }
            }
          }
        });
      } catch (err) {
        console.error("Click / decode error:", err);
        chartContainer.style.display = "none";
      }
    });
  </script>
</body>
</html>
